2 SUM Problem
http://coderevisited.com/2-sum-problem/
http://www.careercup.com/question?id=15206700


The 2 sum problem is a classic variation of the subset sum problem. It is defined as the following: 
You have an unsorted array, and you are given a value S. Find all pairs of elements in the array that
add up to value S. 
2 solutions - one minimizes space complexity, and the other time. As stated in the "hint", 
one approach is to hash the entire array, and then for each element check if S-array[j] is in the 
hash table. This takes O(n) time and O(n) space to store the array. 
Alternatively, if one wishes to minimize space complexity, simply sort the array. Then, have two
pointers - one initialized to array[0] and the other array[length-1]. Then check the sums; if the
sum is > S, decrement the right pointer. If it is < S, increment the left pointer.

Sample Java code for the second method of finding 2sum:
public static void findTwoSum(int[] A, int x) {
    Arrays.sort(A);        
    int start = 0;
    int end = A.length - 1;
    boolean found = false;
    while (!found && start < end) {
        if (A[start] + A[end] == x)
            found = true;
        else if (A[start] + A[end] > x)
            end--;
        else if (A[start] + A[end] < x)
            start++;
    }
    if (found)
        System.out.println("Sum " + x
                + " is found, values the making sum are " + A[start] + " , "
                + A[end]);
    else
        System.out.println("No pair exists whose sum is " + x);
}


To reverse a string in Java:

package BST_Demo;

public class ReverseArray {
public static void main(String[] args) {
	
	String givenString = "Am I bad ? ";
			StringBuilder reverse=new StringBuilder(givenString.length());
			for(int i=givenString.length()-1;i>=0;i--){
				reverse.append(givenString.charAt(i));
			}
			System.out.println(reverse);
	
}
}


How to implement a stack which will support following operations in O(1) time complexity?
1) push() which adds an element to the top of stack.
2) pop() which removes an element from top of stack.
3) findMiddle() which will return middle element of the stack.
4) deleteMiddle() which will delete the middle element.
Push and pop are standard stack operations.

http://www.geeksforgeeks.org/design-a-stack-with-find-middle-operation/


Very IMP Q -> Disadvantages of HashMap or Hashtable OR Why is BALANCED TREES better than using Hashtable
or HashMap?
Ans ->
Very IMP Q -> Disadvantages of HashMap or Hashtable OR Why is BALANCED TREES better than using Hashtable
or HashMap?
Ans -> 
In short:
1) Requires more main memory
2) Hashing algorithm does not result in spatial locality. Because hash tables cause
access patterns that jump around, this can trigger microprocessor cache misses that cause long delays.
3) Similar key types will result in more collision and hence the hashtable would be more like a linkedlist.
Collisions also ruin memory utilization- if I have 70 elements in 100 buckets, but those 70 elements hash to 
only 4 buckets (and yes, Virginia, I’ve seen collision rates this bad), then 96 of my buckets aren’t doing
me any good at, I’m just wasting that space.
4) Occasionally HashMap/Hashtable requires resizing when the original size of HashMap/Hashtable buckets
are full. Resizing takes O(n) time as the elements from the previous hashtable/HashMap are transferred to
a new bigger Hashtable/HashMap. This is not good for implementation.
5) The concept that Hashtables/HashMap offers O(constant) (aka O(1) ) time complexity
for insertion, deletion and searchingis something to rethink on as the datastructure givies that
time complexity on a average scale, which is called as "AMORTIZED" time complexity. That means that there
would be atleast on instance out of n instances where the Time Complexity would be O(n) and not O(constant).
This is the time when the HashMap/Hashtable requires resizing.

http://stackoverflow.com/questions/6924852/what-are-the-disadvantages-to-hashmaps
http://web.archive.org/web/20090430172748/http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
http://en.wikipedia.org/wiki/Hash_table#Drawbacks


/* Program to find the 2nd minimum element in the array */
#include <stdio.h>
#include <limits.h> /* For INT_MAX */
 
/* Function to print first smallest and second smallest elements

Algorithm:

1) Initialize both first and second smallest as INT_MAX
   first = second = INT_MAX
2) Loop through all the elements.
   a) If the current element is smaller than first, then update first 
       and second. 
   b) Else if the current element is smaller than second then update 
    secondAlgorithm:

*/

void print2Smallest(int arr[], int arr_size)
{
    int i, first, second;
 
    /* There should be atleast two elements */
    if (arr_size < 2)
    {
        printf(" Invalid Input ");
        return;
    }
 
    first = second = INT_MAX;
    for (i = 0; i < arr_size ; i ++)
    {
        /* If current element is smaller than first then update both
          first and second */
        if (arr[i] < first)
        {
            second = first;
            first = arr[i];
        }
 
        /* If arr[i] is in between first and second then update second  */
        else if (arr[i] < second && arr[i] != first)
            second = arr[i];
    }
    if (second == INT_MAX)
        printf("There is no second smallest element\n");
    else
        printf("The smallest element is %d and second Smallest element is %d\n",
               first, second);
}
 
 
/* Driver program to test above function */
int main()
{
    int arr[] = {12, 13, 1, 10, 34, 1};
    int n = sizeof(arr)/sizeof(arr[0]);
    print2Smallest(arr, n);
    return 0;
}


Longest Common Substring Problem:
source -> http://www.geeksforgeeks.org/dynamic-programming-set-4-longest-common-subsequence/

/* Dynamic Programming implementation of LCS problem */
#include<stdio.h>
#include<stdlib.h>
  
int max(int a, int b);
  
/* Returns length of LCS for X[0..m-1], Y[0..n-1] */
int lcs( char *X, char *Y, int m, int n )
{
   int L[m+1][n+1];
   int i, j;
  
   /* Following steps build L[m+1][n+1] in bottom up fashion. Note 
      that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] */
   for (i=0; i<=m; i++)
   {
     for (j=0; j<=n; j++)
     {
       if (i == 0 || j == 0)
         L[i][j] = 0;
  
       else if (X[i-1] == Y[j-1])
         L[i][j] = L[i-1][j-1] + 1;
  
       else
         L[i][j] = max(L[i-1][j], L[i][j-1]);
     }
   }
    
   /* L[m][n] contains length of LCS for X[0..n-1] and Y[0..m-1] */
   return L[m][n];
}
  
/* Utility function to get max of 2 integers */
int max(int a, int b)
{
    return (a > b)? a : b;
}
  
/* Driver program to test above function */
int main()
{
  char X[] = "AGGTAB";
  char Y[] = "GXTXAYB";
  
  int m = strlen(X);
  int n = strlen(Y);
  
  printf("Length of LCS is %d\n", lcs( X, Y, m, n ) );
  
  getchar();
  return 0;
}
Time Complexity of the above implementation is O(mn) which is much better than the worst case
time complexity of Naive Recursive implementation.

Please write comments if you find anything incorrect, or you want to share more information about
the topic discussed above.



